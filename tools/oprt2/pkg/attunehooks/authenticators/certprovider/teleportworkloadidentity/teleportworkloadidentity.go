/*
 *  Copyright 2025 Gravitational, Inc
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package teleportworkloadidentity

import (
	"context"
	"crypto/tls"
	"errors"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"time"

	"github.com/gravitational/shared-workflows/tools/oprt2/pkg/attunehooks/authenticators/certprovider"
)

// TeleportWorkloadIdentityProvider provides a certificate via Teleport Workload Identity (SPIFFE).
// It expects the environment to already be authenticated with Teleport, but handles requesting and
// renewing the certificate from Teleport.
type TeleportWorkloadIdentityProvider struct {
	*certprovider.RenewableCertProvider

	workloadIdentityName string
	ttl                  time.Duration
}

var _ certprovider.Provider = &TeleportWorkloadIdentityProvider{}

type TeleportWorkloadIdentityProviderOpt func(twip *TeleportWorkloadIdentityProvider)

// WithTTL sets the cert expiration time.
func WithTTL(ttl time.Duration) TeleportWorkloadIdentityProviderOpt {
	return func(twip *TeleportWorkloadIdentityProvider) {
		twip.ttl = ttl
	}
}

func NewTeleportWorkloadIdentityProvider(workloadIdentityName string, opts ...TeleportWorkloadIdentityProviderOpt) *TeleportWorkloadIdentityProvider {
	twip := &TeleportWorkloadIdentityProvider{
		workloadIdentityName: workloadIdentityName,
		ttl:                  15 * time.Minute,
	}

	for _, opt := range opts {
		opt(twip)
	}

	twip.RenewableCertProvider = certprovider.NewRenewableCertProvider(2*time.Minute, twip.getClientCertificate)

	return twip
}

// getClientCertificate always provides a new client certificate (or errors).
func (twip *TeleportWorkloadIdentityProvider) getClientCertificate(context.Context) (clientAuthCert *tls.Certificate, err error) {
	// Create a temporary directory to store the keypair in
	credentialsDirectory, err := os.MkdirTemp("", "twi-*")
	if err != nil {
		return nil, fmt.Errorf("failed to create temporary directory for outputting TWI keypair: %w", err)
	}

	// Ensure that the temp dir (which possibly contains credentials) is cleaned up. This function reads it's contents into memory
	// so there is no need to keep it around.
	defer func() {
		cleanupErr := os.RemoveAll(credentialsDirectory)
		if cleanupErr == nil || os.IsNotExist(cleanupErr) {
			return
		}
		cleanupErr = fmt.Errorf("failed to cleanup credentials directory (credential leak!): %w", err)

		err = errors.Join(err, cleanupErr)
	}()

	// Use `tsh` to generate the certificate
	// The API call in the Teleport API package depends on code in the "lib" package that is not intended
	// to be exported. This is the most stable, compatible option.
	cmd := exec.Command("tsh", "workload-identity", "issue-x509",
		"--output", credentialsDirectory,
		"--name-selector", twip.workloadIdentityName,
		"--credential-ttl", twip.ttl.String(),
	)
	cmd.Stdout = os.Stdout
	cmd.Stdin = os.Stdin
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return nil, fmt.Errorf("failed to get SVID certificate for client authentication: %w", err)
	}

	// Load the keypair files generated by Teleport
	privateKeyPath := filepath.Join(credentialsDirectory, "svid_key.pem")
	privateKeyContents, err := os.ReadFile(privateKeyPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load generated client private key from %q: %w", privateKeyPath, err)
	}

	publicKeyPath := filepath.Join(credentialsDirectory, "svid.pem")
	publicKeyContents, err := os.ReadFile(publicKeyPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load generated client public key from %q: %w", publicKeyPath, err)
	}

	chainPath := filepath.Join(credentialsDirectory, "svid_bundle.pem")
	chainContents, err := os.ReadFile(chainPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load generated cert chain from %q: %w", chainPath, err)
	}

	// Build the cert
	cert, err := tls.X509KeyPair(append(publicKeyContents, chainContents...), privateKeyContents)
	if err != nil {
		return nil, fmt.Errorf("failed to parse chain, public key, and/or private key: %w", err)
	}

	return &cert, nil
}
